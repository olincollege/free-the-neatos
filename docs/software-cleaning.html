<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="author" content="Stephan Risi" />
    <meta charset="utf-8" />

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="images/home.jpg" />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"
    ></script>
    <title>Cleaning - Free the Neatos</title>
    <script>
      $(function () {
        $("#header").load("header.html");
      });
    </script>
    <link href="css/main.css" rel="stylesheet" />
    <script>
      // Mobile menu toggle functionality - use event delegation since header loads asynchronously
      $(document).ready(function () {
        function setupMobileMenu() {
          // Toggle mobile menu - use event delegation
          $(document)
            .off("click", ".mobile-menu-toggle")
            .on("click", ".mobile-menu-toggle", function (e) {
              e.preventDefault();
              e.stopPropagation();
              var isActive = $(this).hasClass("active");
              $(this).toggleClass("active");
              $(".sidebar").toggleClass("active");
              $(".mobile-overlay").toggleClass("active");
              // Prevent body scroll when menu is open
              if (!isActive) {
                $("body").addClass("menu-open");
              } else {
                $("body").removeClass("menu-open");
              }
            });

          // Close menu when overlay is clicked
          $(document)
            .off("click", ".mobile-overlay")
            .on("click", ".mobile-overlay", function (e) {
              e.preventDefault();
              e.stopPropagation();
              $(".mobile-menu-toggle").removeClass("active");
              $(".sidebar").removeClass("active");
              $(this).removeClass("active");
              $("body").removeClass("menu-open");
            });
        }

        // Set up mobile menu immediately and after delays to ensure header is loaded
        setupMobileMenu();
        setTimeout(setupMobileMenu, 100);
        setTimeout(setupMobileMenu, 500);
        setTimeout(setupMobileMenu, 1000);
      });

      // Close menu when a nav link is clicked (on mobile) - use event delegation
      $(document).on("click", ".nav-link", function () {
        if ($(window).width() <= 767) {
          $(".mobile-menu-toggle").removeClass("active");
          $(".sidebar").removeClass("active");
          $(".mobile-overlay").removeClass("active");
          $("body").removeClass("menu-open");
        }
      });

      // Set up active links and add decorative image after header loads
      $(document).ready(function () {
        function setupNavigation() {
          var currentPage =
            window.location.pathname.split("/").pop() || "index.html";
          var isMilestonePage = currentPage.includes("milestone");
          var isSoftwarePage = currentPage.includes("software");

          $(".nav-link").each(function () {
            var linkHref = $(this).attr("href");
            if (!linkHref) return;

            var linkPage = linkHref.split("#")[0].split("/").pop();

            // Check if this link matches current page
            if (
              linkPage === currentPage ||
              (currentPage === "" && linkPage === "index.html") ||
              (isMilestonePage &&
                linkHref.includes("milestone") &&
                currentPage === linkPage) ||
              (isSoftwarePage &&
                linkHref.includes("software") &&
                currentPage === linkPage)
            ) {
              $(this).addClass("active");
            }
          });

          // Add decorative robot image to sidebar
          if ($(".sidebar-decorative-image").length === 0) {
            $(".sidebar-nav").after(
              '<div class="sidebar-decorative-image"><img src="images/cleaning.jpg" alt="Robot doodle" /></div>'
            );
          }
        }

        // Try to set up navigation immediately, and also after a short delay to ensure header is loaded
        setTimeout(setupNavigation, 100);
        setTimeout(setupNavigation, 500);
      });
    </script>
  </head>

  <body>
    <div id="header"></div>
    <main class="main-content">
      <div class="content-wrapper">
        <h1>Cleaning</h1>
        <p>
          In the cleaning mode, the robot plans and executes a path to cover the
          entire area of the room, given a map created by the mapping mode. To
          do this, we used Boustrophedon Cellular Decomposition (BCD) for the
          coverage path planning. At a high level, BCD breaks the area into
          cells, then plans a zig zag (lawn mower) path to cover the area of
          each cell. To get from the end of the previous cell to the start of
          the next cell, we used A*. More details on these algorithms and the
          path following is available on the
          <a href="software-mapping.html">Mapping</a> and
          <a href="software-both.html">Path Planning and Execution</a> pages.
        </p>
        <p>
          Additionally, for localization during cleaning, we developed a custom
          implementation of an extended kalman filter. More details are
          available on the
          <a href="software-kalman.html">Kalman Filter</a> page.
        </p>
        <p>
          <img
            src="images/cleaning.gif"
            alt="Mapping Algorithm"
            class="content-img"
          />
        </p>
        <h2>Architecture</h2>
        <p>
          Here is a diagram of the cleaning mode architecture. There is a main
          Cleaning node that manages the process. It gets the localization
          information from kalman filter node, which it uses to path plan with
          the A* and BCD functions. It calls the Waypoint Following Action
          server to execute the path.
        </p>
        <p>
          <img
            src="images/image3.jpg"
            alt="Cleaning Architecture"
            class="content-img"
          />
        </p>

        <h2>Algorithm</h2>
        <p>Here is the high level algorithm the Cleaning Node follows:</p>
        <ol>
          <li>Pull the map from the map server</li>
          <li>
            Call BCD with the map to generate the coverage cells and paths
          </li>
          <li>
            Loop through coverage cells
            <ol>
              <li>Plan a path using A* to get to start of the cell</li>
              <li>Execute path with waypoint following action server</li>
              <li>
                If the waypoint following action server is unsuccessful (hits an
                object), re-plan and execute path
              </li>
              <li>
                Execute the cell's coverage path with the waypoint following
                action server
              </li>
              <li>
                If the waypoint following the server is unsuccessful, plan and
                execute a path to the 3rd waypoint after the failure. Then
                resuming cleaning coverage path
              </li>
            </ol>
          </li>
        </ol>
        <p>
          One key feature of the cleaning is that if the waypoint following
          server is unsuccessful at following the path, it will either retry by
          planning a new path or it will resume cleaning the cell a few
          waypoints later. This maximizes coverage and can handle minor map
          changes or localization errors. Here is a demo of that.
        </p>
        <p>
          <img
            src="images/bump_and_continue.gif"
            alt="Mapping Algorithm"
            class="content-img"
          />
        </p>

        <h2>Boustrophedon Cellular Decomposition</h2>
        <p>
          To generate an efficient coverage path during cleaning, we use a
          slightly modified Boustrophedon Cellular Decomposition (BCD). BCD is a
          classic coverage path planning algorithm designed to systematically
          cover an entire area while minimizing redundant motion. At a high
          level, the algorithm decomposes the free space in a map into a set of
          connected cells based on obstacle boundaries. Each cell represents a
          region that can be covered with simple, back-and-forth motion, similar
          to a lawnmower pattern. By breaking the problem into these smaller
          regions, BCD makes full-area coverage tractable even in environments
          with complex obstacle layouts. Different color path lines represent
          different cells created by our BCD algorithm.
        </p>
        <p>
          <img
            src="images/image8.png"
            alt="BCD Cells"
            class="content-img content-img--sm"
          />
        </p>
        <p>
          Once the cells are generated, the robot follows a zig-zag coverage
          path within each cell to ensure that all reachable space is visited.
          When transitioning between cells, coverage paths alone are
          insufficient, so we use a general-purpose planner to move the robot
          from the end of one cell's coverage path to the start of the next.
          This combination allows the system to maintain both efficient local
          coverage and reliable global navigation, even when cells are separated
          by narrow passages or irregular geometry.
        </p>
        <p>
          Our BCD algorithm is slightly modified to allow safer movement between
          travel lines. Rather than driving straight from the end of one line to
          the start of the next, which would often cause a collision with an
          obstacle, the neato will travel along the line it just cleaned until
          it reaches a safe spot to move over to the start of the next line.
          Experimentally this has completely removed all chances of collision
          during transition between cleaning lines.
        </p>
        <p>
          Overall, BCD proved to be a reliable choice for our cleaning task. The
          structure of the algorithm makes it easy to reason about coverage
          while still working well with a grid-based map and a real robot. With
          our small modification to how the robot transitions between cleaning
          lines, the system is able to cover most of the mapped area safely and
          consistently, without excessive re-planning or repeated passes.
        </p>

        <h2>Limitations and Future Work</h2>
        <p>
          Cleaning mode has a few major limitations. First, it currently doesn't
          clean within a ~foot radius next to obstacles, including around the
          edge of the room, to prevent crashes. Our implementations of A* and
          BCD aren't designed for tight tolerances. This could be overcome by
          adding a new step to the cleaning process which is tracing the
          perimeter of obstacles and the room first using a proportional
          controller. This is similar to how real robot vacuums operate.
        </p>
        <p>
          Another constraint is that the path planning and the map are static,
          so it depends on a constant environment. This is an unrealistic
          expectation because people and pets exist in a real environment,
          furniture, such as chairs, frequently move, and people put stuff on
          the floor. The next step would be dynamic path planning using the
          real-time lidar data to update the occupancy field in real time and
          replan if the lidar doesn't match well. We would need to do additional
          research on algorithms for an approach beyond that.
        </p>
        <p>
          <img
            src="images/image2.png"
            alt="Cleaning Limitations"
            class="content-img content-img--sm"
          />
        </p>
      </div>
    </main>
  </body>
</html>
