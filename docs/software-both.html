<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="author" content="Stephan Risi" />
    <meta charset="utf-8" />
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="images/home.jpg" />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"
    ></script>
    <title>Path Planning and Execution - Free the Neatos</title>
    <script>
      $(function () {
        $("#header").load("header.html");
      });
    </script>
    <link href="css/main.css" rel="stylesheet" />
    <script>
      // Mobile menu toggle functionality - use event delegation since header loads asynchronously
      $(document).ready(function () {
        function setupMobileMenu() {
          // Toggle mobile menu - use event delegation
          $(document).off("click", ".mobile-menu-toggle").on("click", ".mobile-menu-toggle", function (e) {
            e.preventDefault();
            e.stopPropagation();
            var isActive = $(this).hasClass("active");
            $(this).toggleClass("active");
            $(".sidebar").toggleClass("active");
            $(".mobile-overlay").toggleClass("active");
            // Prevent body scroll when menu is open
            if (!isActive) {
              $("body").addClass("menu-open");
            } else {
              $("body").removeClass("menu-open");
            }
          });

          // Close menu when overlay is clicked
          $(document).off("click", ".mobile-overlay").on("click", ".mobile-overlay", function (e) {
            e.preventDefault();
            e.stopPropagation();
            $(".mobile-menu-toggle").removeClass("active");
            $(".sidebar").removeClass("active");
            $(this).removeClass("active");
            $("body").removeClass("menu-open");
          });
        }

        // Set up mobile menu immediately and after delays to ensure header is loaded
        setupMobileMenu();
        setTimeout(setupMobileMenu, 100);
        setTimeout(setupMobileMenu, 500);
        setTimeout(setupMobileMenu, 1000);
      });

      // Close menu when a nav link is clicked (on mobile) - use event delegation
      $(document).on("click", ".nav-link", function () {
        if ($(window).width() <= 767) {
          $(".mobile-menu-toggle").removeClass("active");
          $(".sidebar").removeClass("active");
          $(".mobile-overlay").removeClass("active");
          $("body").removeClass("menu-open");
        }
      });

      // Set up active links and add decorative image after header loads
      $(document).ready(function () {
        function setupNavigation() {
          var currentPage =
            window.location.pathname.split("/").pop() || "index.html";
          var isMilestonePage = currentPage.includes("milestone");
          var isSoftwarePage = currentPage.includes("software");

          $(".nav-link").each(function () {
            var linkHref = $(this).attr("href");
            if (!linkHref) return;

            var linkPage = linkHref.split("#")[0].split("/").pop();

            // Check if this link matches current page
            if (
              linkPage === currentPage ||
              (currentPage === "" && linkPage === "index.html") ||
              (isMilestonePage &&
                linkHref.includes("milestone") &&
                currentPage === linkPage) ||
              (isSoftwarePage &&
                linkHref.includes("software") &&
                currentPage === linkPage)
            ) {
              $(this).addClass("active");
            }
          });

          // Add decorative robot image to sidebar
          if ($(".sidebar-decorative-image").length === 0) {
            $(".sidebar-nav").after(
              '<div class="sidebar-decorative-image"><img src="images/both.png" alt="Robot doodle" /></div>'
            );
          }
        }

        // Try to set up navigation immediately, and also after a short delay to ensure header is loaded
        setTimeout(setupNavigation, 100);
        setTimeout(setupNavigation, 500);
      });
    </script>
  </head>

  <body>
    <div id="header"></div>
    <main class="main-content">
      <div class="content-wrapper">
        <h1>Path Planning and Execution</h1>

        <h2>A* Path Planning</h2>
        <p>
          For the general-purpose planning algorithm to get from place to place,
          we used A*. A* is a graph traversal algorithm to find the shortest
          path between two points. It is more computationally efficient than
          other graph algorithms like Dijkstra's Algorithm or Breadth First
          Search because it uses a heuristic to prioritize paths that take you
          closer to your goal.
        </p>
        <p>
          The way this works in practice is for each potential node to visit
          that is a neighbor of a previously visited node, and a total cost
          score is estimated. This cost for a given node is the sum of the
          actual distance to get from the start to the node and the heuristic's
          estimated cost from the node to the finish. At each iteration of the
          loop, the node with the lowest cost is visited. When you do this
          recursively, the first time you visit the finish node, will always be
          the shortest path.
        </p>
        <p>
          There are a few design decisions for this algorithm. You have to
          decide what the graph you are traversing is, what the heuristic is,
          and what the possible moves are. For the graph, we used the occupancy
          field generated by SLAM. This is a grid of cells, where each cell is
          either an obstacle, empty, or unknown. We treated unknown cells as
          empty. For the possible moves, we chose to allow the robot to move in
          8 directions, so all adjacent grid cells, including on the diagonal.
          For the heuristic, we chose octile distance, which is the exact
          shortest distance on a grid when you can move diagonally, because it
          treats a diagonal move accurately as sqrt(2).
        </p>
        <p>
          Additionally, we added a small multiplier to the heuristic value so
          that it prioritizes moves towards the goal. This is called weighted
          A*. Without this, on a grid-based setup, the algorithm has no
          incentive to prioritize moves that bring it directly towards the goal
          because many moves have the same weight. As shown in the graph, adding
          this heuristic significantly cuts down on visited nodes.
        </p>
        <p>
          <img src="images/image10.png" alt="A* Path Planning" class="content-img" />
        </p>
        <p>
          The final decision for the algorithm is how to account for the robot's
          width to ensure it doesn't crash into any obstacles, since the robot
          is bigger than a single grid cell. The simplest way to do this is to
          inflate each obstacle by a little more than half of the robot's width.
          This ensures the robot can fit in any cell that is still empty. Here
          is a visual of the map with the obstacles inflated.
        </p>
        <p>
          <img
            src="images/image7.png"
            alt="Obstacle Inflation"
            class="content-img content-img--sm"
          />
        </p>

        <h2>Waypoint Following Server</h2>
        <p>
          To execute the paths generated by the path planning algorithms, we
          wrote an Action Server that takes a trajectory of points and drives
          the robot to each waypoint. An action server is useful instead of a
          simple node with topic-only communication because it enables two-way
          communication without the clutter of many topics. This is perfect for
          long-running tasks and gives the client control to cancel a task
          mid-progress, allows the server to communicate its progress, and the
          final result. Setting up that functionality with topics would require
          either many topics or a complex scheme. Action servers provide a
          standardized way to do this.
        </p>
        <p>
          To navigate the neato toward each waypoint, a proportional controller
          is used to control the angular velocity. The error input to the
          controller is the angle difference between the current heading and the
          angle needed to drive directly towards the waypoint. Once the error is
          less than 15 degrees, it drives with a constant linear velocity
          forward, while continuing to correct the angle. Once the robot is
          within a small radius of the waypoint, the next waypoint is set as the
          target.
        </p>
        <p>
          Another useful feature we added to the waypoint follower server is
          retracing the path backwards, then aborting the action if the Neato
          bumps into anything. Retracing the path backwards is useful to ensure
          it can navigate out of a tight space if it gets into one. To drive
          backwards, it sets the target waypoint to the previous waypoint. Then,
          180 degrees is added to the target direction, and the linear velocity
          and angular velocity are set to the opposite.
        </p>
      </div>
    </main>
  </body>
</html>
