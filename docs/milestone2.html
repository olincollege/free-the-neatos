<!DOCTYPE html>
<html lang="en">

<!--The head contains metadata about our page and it's the place where we can load css files (for -->
<!--styling) and javascript files.-->
<head>

    <meta name="author" content="Stephan Risi">
    <meta charset="utf-8">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">-->

    <!-- Load JQuery and Bootstrap. They are javascript library that handle the layouting for us.-->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

    <!--Set the title for the page-->
    <title>Milestone 2 - Free the Neatos</title>

    <!-- The nav bar remains the same for every page, so by defining it in only one file, we only
     need to edit it in one place when we make changes to it. -->
    <script> $(function(){$("#header").load("header.html");});</script>

    <!-- Import the css file, which defines how our website looks -->
    <link href="css/main.css" rel="stylesheet">

    <script>
        // Set up active links after header loads
        $(document).ready(function() {
            function setupNavigation() {
                var currentPage = window.location.pathname.split('/').pop() || 'index.html';
                var isMilestonePage = currentPage.includes('milestone');
                var isSoftwarePage = currentPage.includes('software');
                
                $('.nav-link').each(function() {
                    var linkHref = $(this).attr('href');
                    if (!linkHref) return;
                    
                    var linkPage = linkHref.split('#')[0].split('/').pop();
                    
                    // Check if this link matches current page
                    if (linkPage === currentPage || 
                        (currentPage === '' && linkPage === 'index.html') ||
                        (isMilestonePage && linkHref.includes('milestone') && currentPage === linkPage) ||
                        (isSoftwarePage && linkHref.includes('software') && currentPage === linkPage)) {
                        $(this).addClass('active');
                    }
                });
            }

            // Try to set up navigation immediately, and also after a short delay to ensure header is loaded
            setTimeout(setupNavigation, 100);
            setTimeout(setupNavigation, 500);
        });
    </script>

</head>

<!--We define the elements that we actually want to display in the body element-->
<body>
    <!--This element is a placeholder for the sidebar navigation, which we load above-->
    <div id="header"></div>

    <!--Main content area-->
    <main class="main-content">
        <div class="content-wrapper">
            <h1>Milestone 2</h1>

            <h2>Overview</h2>
            <p>To begin phase two, we did some overall architectural planning to map out who will be responsible for which code and how it will be written, as some systems use overlapping functionality.</p>
            <p>At a high level, there are two main modes of operation. There is a mapping mode that explores to develop the initial map. Once this is complete, it switches into cleaning mode to execute coverage path planning. Here is an overview of the functionality needed, how it will be written, and which mode it is for.</p>
            <p>Both Modes</p>
            <ul>
                <li>
                    A* (function)<br>
                    <ul>
                        <li>Finds an obstacle-avoiding path to the target point</li>
                    </ul>
                </li>
                <li>
                    Driving to waypoints (action server)<br>
                    <ul>
                        <li>Low-level controls that send velocity commands to follow a list of waypoints</li>
                    </ul>
                </li>
            </ul>
            <p>Mapping Mode</p>
            <ul>
                <li>
                    Mapping (node):<br>
                    <ul>
                        <li>Manages the whole mapping process. Uses frontier finding to get target areas to explore. It generates a route to get there with A*, then executes by calling the drive to waypoints action server. Once this completes, it checks if the map is "complete". If not, it repeats.</li>
                    </ul>
                </li>
                <li>
                    Frontier finding (function)<br>
                    <ul>
                        <li>Finds and ranks the best points to explore based on the current slam map and boundaries between empty and unmapped areas</li>
                    </ul>
                </li>
                <li>
                    Map complete (function)<br>
                    <ul>
                        <li>Function to return whether the map is sufficiently explored, based on the existing list of frontiers to explore.</li>
                    </ul>
                </li>
                <li>SLAM toolbox (launch existing SLAM toolbox)</li>
            </ul>
            <p>Cleaning Mode:</p>
            <ul>
                <li>
                    Cleaning (node):<br>
                    <ul>
                        <li>Manages cleaning by orchestrating the use of BCD planning, A*, and drive to waypoints action server</li>
                    </ul>
                </li>
                <li>
                    Localization (node):<br>
                    <ul>
                        <li>Use Kalman filter to publish better localization to topic</li>
                    </ul>
                </li>
                <li>Boustrophedon Cellular Decomposition planning (function/class)</li>
            </ul>

            <h2>Exploration Path Planning</h2>

            <h3>Progress</h3>
            <p>At the moment, the code to find frontiers is nearly done, and the code to rank these frontiers is partially done. We have also outlined what the SLAM exploration control architecture is going to look like.</p>

            <h3>Plan to Finish and Risks</h3>
            <p>The current plan to finish is as follows:</p>
            <ul>
                <li>Finish code to find and rank frontiers.</li>
                <li>Refactor code so that the frontier-finding algorithm is a function and the existing node can hold the SLAM exploration control logic.</li>
                <li>Implement control logic that uses the A* function and waypoint navigation action server to navigate to keypoints.</li>
                <li>Save the map with user input.</li>
            </ul>
            <p>The following functionalities will likely be stretch goals:</p>
            <ul>
                <li>Determine whether an area has been 'fully' explored</li>
            </ul>
            <p>The primary risks here are uncertainty about the final logic and challenges with integration/debugging. The control logic relies on two separate implementations (A* and waypoint navigation) that I am not personally working on, and so I may not be able to fully test components of my code until later on. There is also uncertainty in terms of how much time I will have to dedicate to the project.</p>

            <h2>Coverage Path Planning</h2>

            <h3>Progress</h3>
            <p> Coverage path planning is going well. I've found a couple example implementations on GitHub that I'm referencing for the math. Right now don't have the best sample map, but the main issue right now is that the path goes through sections of wall when traversing from one section to the next occasionally.</p>

            <h3>Plan to Finish and Risks</h3>
            <p>I need to match the occupancy grid I'm getting as an input to the actual grid I use, I need to get the robot to not drive through walls, and I need to measure the Neato for its size for an accurate width of pass.</p>
            <p>As for risks, I'm not 100% sure how to stop the path from colliding with the wall in transitions between sections. Another thing I'm worried about is the accuracy of the map, and the accuracy of the Neato itself. The path may look good on the computer, but how can I allow for a bit of error on the Neato side?</p>

            <h2>SLAM</h2>

            <h3>Progress</h3>
            <ul>
                <li>The slam toolbox is added to the system launch file, and reads /scan and /odom data and publishes an occupancy grid.</li>
            </ul>

            <h3>Plan to Finish and Risks</h3>
            <ul>
                <li>While the robot is in the mapping phase, the occupancy grid is collected. After the robot is done mapping, the occupancy will need to freeze or be copied for the coverage algorithm.</li>
            </ul>

            <h2>Go To Point</h2>

            <h3>Progress</h3>
            <p>We have written a first draft of the waypoint following action server. It is currently fairly simple. It rotates to the direction of the next point, then drives for the calculated amount of time. It currently uses open-loop controls. It also returns feedback on which waypoint it is currently on to the client.</p>

            <h3>Plan to Finish and Risks</h3>
            <p>We will improve the control scheme of going to points as needed by incorporating the Kalman filter/SLAM location data to close the loop. We haven't started A* yet, and this is a priority to finish early this week to test the action server further and as a dependency for the rest of the code.</p>
            <p>The biggest risk is ensuring waypoint reaching accuracy. To mitigate this, the MVP is running in simulation where the sensors are more accurate.</p>

            <h2>Localization</h2>

            <h3>Progress</h3>
            <p>
                Current work has been towards implementing the Iterative Closest Point (ICP) algorithm which will be used to calculate LIDAR odometry, essentially the translation and rotation between 2 scans. There is still a lot of debug work happening for our own implementation, but we found a library that performs ICP with sufficient accuracy that we can use for now.<br>
                <img
                    src="images/m2_kalman.png"
                    alt="Milestone 2 localization placeholder"
                >
            </p>

            <h3>Plan to Finish and Risks</h3>
            <p>ICP for LIDAR odometry will be part of the sensor model, which is part of the whole Kalman Filter. Regarding future development for the filter, the motion model should be fairly straight forward (we hope) where it is based off of velocity commands and its corresponding covariance based on a generic white-noise model. The full sensor model implementation would probably be a little more complex, where I need to figure out how to structure its covariance matrix.</p>
            <p>Regarding risks, the biggest risk is the performance of the filter and the ability to debug it. If the filter performance is bad, the robot is unable to path properly. As a last resort fall-back plan, since we are working in simulation, we could use the ground-truth odometry data provided.</p>

            <h2>Integration Plan</h2>
            <p>To integrate, we plan on getting each section working individually by this weekend, with integrations between closely tied systems already tested. For example, we will have already tested A* with the driving to waypoints action server. We have also coordinated the architecture ahead of time, so there won't be significant architectural conflicts.</p>
            <p>Since this is a complex system with many moving pieces, we do foresee the inevitable integration challenges, so we are planning to meet as a team to work through them over the weekend.</p>
        </div>
    </main>
</body>
</html>

