<!DOCTYPE html>
<html lang="en">
  <!--The head contains metadata about our page and it's the place where we can load css files (for -->
  <!--styling) and javascript files.-->
  <head>
    <meta name="author" content="Stephan Risi" />
    <meta charset="utf-8" />
    <!--<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">-->

    <!-- Load JQuery and Bootstrap. They are javascript library that handle the layouting for us.-->
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"
    ></script>

    <!--Set the title for the page-->
    <title>Github Pages Tutorial</title>

    <!-- The nav bar remains the same for every page, so by defining it in only one file, we only
     need to edit it in one place when we make changes to it. -->
    <script>
      $(function () {
        $("#header").load("header.html");
      });
    </script>

    <!-- Import the css file, which defines how our website looks -->
    <link href="css/main.css" rel="stylesheet" />
  </head>

  <!--We define the elements that we actually want to display in the body element-->
  <body>
    <!--This element is a placeholder for the header with the navbar, which we load above-->
    <div id="header"></div>

    <div class="column">
      <h1 id="milestones">Milestones</h1>

      <section>
        <h2>Milestone 2</h2>

        <h3>Overview</h3>
        <p>To begin phase two, we did some overall architectural planning to map out who will be responsible for which code and how it will be written, as some systems use overlapping functionality.</p>
        <p>At a high level, there are two main modes of operation. There is a mapping mode that explores to develop the initial map. Once this is complete, it switches into cleaning mode to execute coverage path planning. Here is an overview of the functionality needed, how it will be written, and which mode it is for.</p>
        <p>Both Modes</p>
        <ul>
          <li>
            A* (function)<br>
            <ul>
              <li>Finds an obstacle-avoiding path to the target point</li>
            </ul>
          </li>
          <li>
            Driving to waypoints (action server)<br>
            <ul>
              <li>Low-level controls that send velocity commands to follow a list of waypoints</li>
            </ul>
          </li>
        </ul>
        <p>Mapping Mode</p>
        <ul>
          <li>
            Mapping (node):<br>
            <ul>
              <li>Manages the whole mapping process. Uses frontier finding to get target areas to explore. It generates a route to get there with A*, then executes by calling the drive to waypoints action server. Once this completes, it checks if the map is “complete”. If not, it repeats.</li>
            </ul>
          </li>
          <li>
            Frontier finding (function)<br>
            <ul>
              <li>Finds and ranks the best points to explore based on the current slam map and boundaries between empty and unmapped areas</li>
            </ul>
          </li>
          <li>
            Map complete (function)<br>
            <ul>
              <li>Function to return whether the map is sufficiently explored, based on the existing list of frontiers to explore.</li>
            </ul>
          </li>
          <li>SLAM toolbox (launch existing SLAM toolbox)</li>
        </ul>
        <p>Cleaning Mode:</p>
        <ul>
          <li>
            Cleaning (node):<br>
            <ul>
              <li>Manages cleaning by orchestrating the use of BCD planning, A*, and drive to waypoints action server</li>
            </ul>
          </li>
          <li>
            Localization (node):<br>
            <ul>
              <li>Use Kalman filter to publish better localization to topic</li>
            </ul>
          </li>
          <li>Boustrophedon Cellular Decomposition planning (function/class)</li>
        </ul>

        <h3>Exploration Path Planning</h3>

        <h4>Progress</h4>
        <p>At the moment, the code to find frontiers is nearly done, and the code to rank these frontiers is partially done. We have also outlined what the SLAM exploration control architecture is going to look like.</p>

        <h4>Plan to Finish and Risks</h4>
        <p>The current plan to finish is as follows:</p>
        <ul>
          <li>Finish code to find and rank frontiers.</li>
          <li>Refactor code so that the frontier-finding algorithm is a function and the existing node can hold the SLAM exploration control logic.</li>
          <li>Implement control logic that uses the A* function and waypoint navigation action server to navigate to keypoints.</li>
          <li>Save the map with user input.</li>
        </ul>
        <p>The following functionalities will likely be stretch goals:</p>
        <ul>
          <li>Determine whether an area has been ‘fully’ explored</li>
        </ul>
        <p>The primary risks here are uncertainty about the final logic and challenges with integration/debugging. The control logic relies on two separate implementations (A* and waypoint navigation) that I am not personally working on, and so I may not be able to fully test components of my code until later on. There is also uncertainty in terms of how much time I will have to dedicate to the project.</p>

        <h3>Coverage Path Planning</h3>

        <h4>Progress</h4>
        <p> Coverage path planning is going well. I’ve found a couple example implementations on GitHub that I’m referencing for the math. Right now don’t have the best sample map, but the main issue right now is that the path goes through sections of wall when traversing from one section to the next occasionally.</p>

        <h4>Plan to Finish and Risks</h4>
        <p>I need to match the occupancy grid I’m getting as an input to the actual grid I use, I need to get the robot to not drive through walls, and I need to measure the Neato for its size for an accurate width of pass.</p>
        <p>As for risks, I’m not 100% sure how to stop the path from colliding with the wall in transitions between sections. Another thing I’m worried about is the accuracy of the map, and the accuracy of the Neato itself. The path may look good on the computer, but how can I allow for a bit of error on the Neato side?</p>

        <h3>SLAM</h3>

        <h4>Progress</h4>
        <ul>
          <li>The slam toolbox is added to the system launch file, and reads /scan and /odom data and publishes an occupancy grid.</li>
        </ul>

        <h4>Plan to Finish and Risks</h4>
        <ul>
          <li>While the robot is in the mapping phase, the occupancy grid is collected. After the robot is done mapping, the occupancy will need to freeze or be copied for the coverage algorithm.</li>
        </ul>

        <h3>Go To Point</h3>

        <h4>Progress</h4>
        <p>We have written a first draft of the waypoint following action server. It is currently fairly simple. It rotates to the direction of the next point, then drives for the calculated amount of time. It currently uses open-loop controls. It also returns feedback on which waypoint it is currently on to the client.</p>

        <h4>Plan to Finish and Risks</h4>
        <p>We will improve the control scheme of going to points as needed by incorporating the Kalman filter/SLAM location data to close the loop. We haven’t started A* yet, and this is a priority to finish early this week to test the action server further and as a dependency for the rest of the code.</p>
        <p>The biggest risk is ensuring waypoint reaching accuracy. To mitigate this, the MVP is running in simulation where the sensors are more accurate.</p>

        <h3>Localization</h3>

        <h4>Progress</h4>
        <p>
          Current work has been towards implementing the Iterative Closest Point (ICP) algorithm which will be used to calculate LIDAR odometry, essentially the translation and rotation between 2 scans. There is still a lot of debug work happening for our own implementation, but we found a library that performs ICP with sufficient accuracy that we can use for now.<br>
          <img
            src="images/m2_kalman.png"
            alt="Milestone 2 localization placeholder"
          >
        </p>

        <h4>Plan to Finish and Risks</h4>
        <p>ICP for LIDAR odometry will be part of the sensor model, which is part of the whole Kalman Filter. Regarding future development for the filter, the motion model should be fairly straight forward (we hope) where it is based off of velocity commands and its corresponding covariance based on a generic white-noise model. The full sensor model implementation would probably be a little more complex, where I need to figure out how to structure its covariance matrix.</p>
        <p>Regarding risks, the biggest risk is the performance of the filter and the ability to debug it. If the filter performance is bad, the robot is unable to path properly. As a last resort fall-back plan, since we are working in simulation, we could use the ground-truth odometry data provided.</p>

        <h3>Integration Plan</h3>
        <p>To integrate, we plan on getting each section working individually by this weekend, with integrations between closely tied systems already tested. For example, we will have already tested A* with the driving to waypoints action server. We have also coordinated the architecture ahead of time, so there won’t be significant architectural conflicts.</p>
        <p>Since this is a complex system with many moving pieces, we do foresee the inevitable integration challenges, so we are planning to meet as a team to work through them over the weekend.</p>
      </section>

<section>
        <h2>Milestone 1</h2>
        <p>
          For the first milestone, we wanted to explore the existing SLAM
          libraries and create an initial working development environment.
          Additionally, we also wanted to research approaches to path planning
          and pick an algorithmic approach.
        </p>

        <h3>SLAM</h3>
        <p>
          We downloaded the
          <a href="https://wiki.ros.org/slam_toolbox">ROS slam toolbox</a> that
          uses information from the odom and scan topics to implement a SLAM
          algorithm. We tested this out in a simulator with the Neato, and
          afterwards got it to work well on the physical Neato in the MAC. Here
          is an example of a map of the hallway:
        </p>
        <p>
          <img
            src="images/m1_slam_map.png"
            alt="Milestone 1 hallway map"
            width="400px"
          />
        </p>
        <h3>SLAM Exploration Path Planning</h3>
        <p>
          When the robot first starts out, it does not have a map of the
          surrounding area. A map will eventually be created using SLAM, but for
          this map to be created, the robot needs to explore its environment.
          This will be done by directing the robot to pathfind to different
          frontiers, or delineated lines between open and unexplored areas
          (respectively white and grey-blue on the SLAM map above). The
          algorithm will prioritize frontiers that are larger and/or closer to
          the robot, and the pathfinding to these frontiers will be done using a
          standard algorithm like A*.
        </p>

        <h3>Coverage Path Planning</h3>
        <p>
          Once we have generated a map of the space, we want the Neato to drive
          and cover all the area as efficiently as possible, so the entire floor
          is cleaned (in spirit). There are many approaches to do this, such as
          a spiral around the room, kind of like mowing the lawn. We decided to
          use Boustrophedon Decomposition (BD). This takes a discrete map,
          creates sections of the floor between the obstacles, and drives over
          each section with “S”s before moving onto the next section. Example:
        </p>
        <p>
          <img
            src="images/m1_path_planning.gif"
            alt="Gif showing path planning"
            width="450px"
          />
        </p>
        <p>
          Taking a discrete map, we will section it using BD. We will then use
          A* to move between two sections to the next step. Here’s an example of
          the process on an actual cleaning robot simulation:
        </p>
        <p>
          <img
            src="images/m1_cleanbot.gif"
            alt="Gif showing cleaning path planning"
            width="450px"
          />
        </p>

        <h3>Setup Status</h3>
        <p>
          We are doing a Neato-based project, so the computational setup is the
          same as the first part of the course. As such, everyone is already set
          up. We also have a shared repo, which is where this website is hosted.
        </p>

        <h3>Project Components</h3>
        <p>
          There are two main modes the robot will operate in. The first is
          mapping when it is introduced into a new space. Then, once it has
          mapped the environment, it can run the cleaning mode.
        </p>

        <h4>Mapping:</h4>
        <ul>
          <li>
            SLAM - Andrew - Use the ROS slam toolbox. Basic testing has been
            completed
          </li>
          <li>
            Exploration pathplanning - Franklin - Researching
            math/implementations
          </li>
          <li>Kalman filter for improved odom - Jojo - Researching math</li>
        </ul>

        <h4>Cleaning:</h4>
        <ul>
          <li>Kalman filter for improved odom - Jojo - Researching math</li>
          <li>
            Particle filter/AMCL for localization - TBD - Will use either a
            particle filter from project 2 or AMCL ROS package
          </li>
          <li>
            Path planning: Andrew and Cian
            <ul>
              <li>
                Boustrophedon Decomposition (BD) - Initial research completed to
                choose the method
              </li>
              <li>A* - Already have a conceptual overview</li>
              <li>Robot commands to traverse between 2 points</li>
            </ul>
          </li>
        </ul>

        <h3>MVP and Stretch Goals</h3>
        <p>
          Our MVP is still on track to be a working simulator implementation
          with all the algorithmic steps above. Since our proposal, we have
          included using a particle filter for localization.
        </p>
        <p>
          For stretch goals, we will bring more of the algorithms in-house. We
          are considering implementing 2D SLAM or modifying one of our own
          particle filter implementations from a previous project instead of
          using the ROS packages.
        </p>

        <h3>Risks of Reaching MVP</h3>
        <p>
          One risk is depending on the SLAM toolbox. If the map isn’t accurate
          enough, then the path planning during the exploration and cleaning
          steps will be wrong. Also, there is a chance that the SLAM toolboxes'
          localization isn’t accurate enough, which will make the exploration
          more challenging as well. We are hoping to mitigate both risks with a
          Kalman filter to improve the odometry.
        </p>
        <p>
          Another risk is the algorithmic complexity of Boustrophedon
          Decomposition for the cleaning path planning. It may be too
          challenging to get a working implementation in the needed time. If
          this is the case, we will explore simpler space coverage path planning
          algorithms.
        </p>

        <h3>Milestone 2 Goals</h3>
        <ul>
          <li>
            SLAM Exploration – Create a testing/visualization setup and be able
            to identify + rank individual frontiers on a SLAM map
          </li>
          <li>
            Kalman Filter - Write a working implementation of a Kalman filter
            for a toy environment
          </li>
          <li>
            Cleaning path planning - Be partway through implementing the
            cleaning pipeline
          </li>
          <li>
            Overall path planning - Implement and test A* on real Neato in real
            environment
          </li>
        </ul>
      </section>
    </div>
  </body>
</html>
